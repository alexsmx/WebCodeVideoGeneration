<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Typer Recorder</title>
    <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.2/lib/codemirror.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/codemirror@5.65.2/lib/codemirror.min.css">
    <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.2/mode/javascript/javascript.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.2/mode/go/go.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.2/mode/clike/clike.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.2/mode/ruby/ruby.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.2/mode/htmlmixed/htmlmixed.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.2/mode/xml/xml.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.2/mode/css/css.js"></script>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        textarea { width: 100%; height: 200px; }
        #typing-area { border: 1px solid #ccc; padding: 10px; margin-top: 20px; position: relative; font-family: monospace;font-variant: normal !important;}
        button { margin-top: 10px; }
        .editor-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: transparent;
            z-index: 10;
        }
        video {
            width: auto;
            max-width: 100%;
        }
    </style>
</head>
<body>
    <h1>Code Typer Recorder</h1>
    <textarea id="code-input" placeholder="Paste your code here..."></textarea>
    <label for="typing-speed">Typing Speed:</label>
    <input type="range" id="typing-speed" min="1" max="10" value="5">
    <span id="speed-display"></span>
    <button onclick="startTyping()">Start Typing Simulation</button>
    <div id="element-to-record" style="border: 5px solid gray; border-radius: 5px; padding: 20px; margin: 20px;width: 480px; height: 360px;">
        <div id="typing-area"></div>
    </div>
    <div style="display: none;">
        <video controls autoplay playsinline id="preview-video"></video>
    </div>
    <canvas id="background-canvas" style="position:absolute; top:-99999999px; left:-9999999999px;"></canvas>
    <script src="/static/js/RecordRTC.js"></script>
    <script src="https://www.webrtc-experiment.com/html2canvas.min.js"></script>
    <script>
        let editor;
        let mediaRecorder;
        let recordedChunks = [];
        let isSimulationRunning = false;
        let baseTypingSpeed = 100;

        
        var elementToRecord = document.getElementById('element-to-record');
        var canvas2d = document.getElementById('background-canvas');
        var context = canvas2d.getContext('2d');

        canvas2d.width = elementToRecord.clientWidth;
        canvas2d.height = elementToRecord.clientHeight;

        var isRecordingStarted = false;
        var isStoppedRecording = false;
        
        (function looper() {
            if(!isRecordingStarted) {
                return setTimeout(looper, 500);
            }

            html2canvas(elementToRecord, {letterRendering: true}).then(function(canvas) {
                context.clearRect(0, 0, canvas2d.width, canvas2d.height);
                context.drawImage(canvas, 0, 0, canvas2d.width, canvas2d.height);

                if(isStoppedRecording) {
                    return;
                }

                requestAnimationFrame(looper);
            });
        })();
        var canvasStream = canvas2d.captureStream();

        var audioPlusCanvasStream = new MediaStream();

        canvasStream.getVideoTracks().forEach(function(track) {
            audioPlusCanvasStream.addTrack(track);
        });

        navigator.mediaDevices.getUserMedia({
            audio: {
                noiseSuppression: false,
                echoCancellation: false,
            }}).then(function(mic) {
            audioPlusCanvasStream.addTrack(mic.getTracks()[0]);
        });

        var recorder = new RecordRTC(audioPlusCanvasStream, {
            type: 'video'
        });

        function getIndentation(line) {
            const match = line.match(/^(\s*)/);
            return match ? match[1] : '';
        }
        function updateTypingSpeed() {
            const speed = document.getElementById("typing-speed").value;
            const charactersPerMinute = Math.round(60 * 1000 / (1200 - speed * 100));
            document.getElementById("speed-display").textContent = `${charactersPerMinute} characters/minute`;
        }

        document.getElementById("typing-speed").addEventListener("input", updateTypingSpeed);
        updateTypingSpeed();
        let spokenComments = [];

        function extractSpokenComments(code) {
            const regex = /(?:\/\/!|#!|--!|%!|'!|\/\*!|\{-!|"""!|'''!)\s*(?:\[([a-z]{2})\])?\s*(.*?)(?:\n|\*\/|\-\}|"""|'''|$)/gs;
            let match;
            const comments = [];
            while ((match = regex.exec(code)) !== null) {
                comments.push({
                    lang: match[1] || 'en',
                    text: match[2].trim()
                });
            }
            return comments;
        }

        async function playAudio(text, lang = 'en') {
            try {
                const response = await fetch('/generate_audio', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ text, lang }),
                });
                const data = await response.json();
                if (data.audio_path) {
                    const audio = new Audio(data.audio_path);
                    await audio.play();
                }
            } catch (error) {
                console.error('Error playing audio:', error);
            }
        }

        function getRandomDelay(min, max) {
            return Math.floor(Math.random() * (max - min + 1) + min);
        }

        function simulateThinkingPause() {
            return new Promise(resolve => setTimeout(resolve, getRandomDelay(500, 1000)));
        }



        function disableEditorInteraction() {
            const overlay = document.createElement('div');
            overlay.className = 'editor-overlay';   
            document.getElementById('typing-area').appendChild(overlay);
            editor.getScrollerElement().style.pointerEvents = 'none';
        }

        function enableEditorInteraction() {
            const overlay = document.querySelector('.editor-overlay');
            if (overlay) {
                overlay.remove();
            }
            editor.getScrollerElement().style.pointerEvents = 'auto';
        }

        function detectLanguage(code) {
            if (/\b(fn|let|mut|impl|struct|enum)\b/.test(code)) return "rust";
            if (/\b(func|package|import|chan|defer|go|map|interface)\b/.test(code)) return "go";
            if (/\b(public|private|class|interface|extends|implements)\b/.test(code)) return "clike";
            if (/\b(def|module|require|end|rescue|attr_accessor)\b/.test(code)) return "ruby";
            if (/\b(<html|<body|<head|<script|<style)\b/.test(code)) return "htmlmixed";
            if (/\b(<\?xml|<([a-z]+:)?[a-z]+(\s|>))\b/.test(code)) return "xml";
            if (/\b(@media|@keyframes|@font-face)\b/.test(code)) return "css";
            if (/\b(interface|namespace|declare|type|enum)\b/.test(code)) return "typescript";
            return "javascript";
        }

        // Initialize CodeMirror
        document.addEventListener('DOMContentLoaded', (event) => {
            const initialCode = document.getElementById("code-input").value;
            const detectedLanguage = detectLanguage(initialCode);
            editor = CodeMirror(document.getElementById("typing-area"), {
                lineNumbers: true,
                mode: detectedLanguage,
                theme: "default"
            });
        });

        function isCommentStart(code, index) {
            return code.slice(index).match(/^(\/\/!|#!|--!|%!|'!|\/\*!|\{-!|"""!|'''!)\s*(?:\[[a-z]{2}\])?\s*/) !== null;
        }

        async function startTyping() {
            if (isSimulationRunning) return;
            isSimulationRunning = true;
            document.querySelector('button[onclick="startTyping()"]').disabled = true;

            try {
                await startRecording();
            } catch (error) {
                console.error('Failed to start recording:', error);
                isSimulationRunning = false;
                document.querySelector('button[onclick="startTyping()"]').disabled = false;
                return;
            }
            const code = document.getElementById("code-input").value;
            const detectedLanguage = detectLanguage(code);
            editor.setOption("mode", detectedLanguage);
            editor.setOption("readOnly", true);
            editor.getWrapperElement().style.backgroundColor = "#f0f0f0";
            disableEditorInteraction();
            let index = 0;
            editor.setValue('');

            baseTypingSpeed = 1200 - document.getElementById("typing-speed").value * 100;
            updateTypingSpeed();
            spokenComments = extractSpokenComments(code);


            async function typeChar() {
                if (index < code.length) {
                    if (isCommentStart(code, index)) {
                        const match = code.slice(index).match(/^(\/\/!|#!|--!|%!|'!|\/\*!|\{-!|"""!|'''!)\s*(?:\[([a-z]{2})\])?\s*(.*?)(?:\n|\*\/|\-\}|"""|'''|$)/s);
                        if (match) {
                            const [fullMatch, commentStart, lang, comment] = match;
                            await playAudio(comment.trim(), lang || 'en');
                            index += fullMatch.length-1;
                        } else {
                            index++;
                        }
                    } else {
                        if (Math.random() < 0.01) {
                            setTimeout(typeChar, getRandomDelay(500, 700));
                            return;
                        }
                        editor.replaceRange(code[index], editor.getCursor());
                        index++;
                    }
                    requestAnimationFrame(() => setTimeout(typeChar, getRandomDelay(baseTypingSpeed * 0.8, baseTypingSpeed * 1.2)));
                } else {
                    editor.setOption("readOnly", false);
                    editor.getWrapperElement().style.backgroundColor = "";
                    isSimulationRunning = false;
                    document.querySelector('button[onclick="startTyping()"]').disabled = false;
                    enableEditorInteraction();
                    stopRecording();
                }
            }

            typeChar();
        }

        async function startRecording() {
            isStoppedRecording =false;
            isRecordingStarted = true;

            recorder.startRecording();
            
        }

        function stopRecording() {
            recorder.stopRecording(function() {
            isRecordingStarted = false;
            isStoppedRecording = true;

            var blob = recorder.getBlob();
            // document.getElementById('preview-video').srcObject = null;
            document.getElementById('preview-video').src = URL.createObjectURL(blob);
            document.getElementById('preview-video').parentNode.style.display = 'block';
            elementToRecord.style.display = 'none';

            // window.open(URL.createObjectURL(blob));
        });
           
    }
    </script>
    <audio id="audio-player" style="display: none;"></audio>
    <script src="https://www.webrtc-experiment.com/common.js"></script>
</body>
</html>